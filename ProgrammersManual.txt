------------PROGRAMMER'S MANUAL FOR (game name TBD)------------

> Overview
This game makes heavy use of the Godot 4.0 game engine and the built-in GDScript language to create complex systems that handle the game logic. It makes full use of OOP (Object Oriented Programming) techniques to create a robust system that allows for easy manipulation of the game's states. The main system that drives the overall gameplay loop is the LevelEvent system, which is a heavily abstracted system that allows for ease of level creation, creation of enemy movement patterns, and event handling. There are also systems that allow for enemy creation (via the use of a base enemy class) along with an enemy pattern creation system that allows for complex enemy attack patterns to be made.

> The LevelEvent System
The LevelEvent system handles most of the game's main gameplay loop. It is found under the LevelEvent.gd file. It can be used to create new stages for the game, which are composed of “waves”. Waves are groups of enemies that spawn in a given amount of time, which must either be eliminated or despawned for the player to continue through the stage. Enemy types, as well as their movement patterns, can be defined in this system, which allows for customization of each stage and wave. It also handles other events aside from enemy spawning, such as level timers, background scrolling, music playing, and “tags” that are used to determine the progression of other events (for example enemy kill counts required for item drops). This is used as a base that can be extended by children to be used to implement stages for the game.


- General use of LevelEvent
To handle all events, the start_event() function is used. It takes a single parameter to start an event:

event - An event that represents the event that is to be triggered. These events are built in to the LevelEvent system.

It is used internally and handles pre-determined events, but can be adjusted to suit the programmer’s needs as necessary.


- Enemy Creation using the LevelEvent System
Enemy spawns are handled by the spawn_entity() function. It takes the following parameters:

type - A PackedScene that represents the enemy type that is to be spawned
location - A Vector2 that contains the spawn location of the enemy
attributes - A dictionary defining some enemy traits, such as movement speed, approach direction, and more


- Waiting using the LevelEvent System
Sometimes, a delay between events is desired in a level. This is handled with the time_wait() function. This function takes a single parameter that serves as the time that the game waits for before triggering the next event:

seconds - An int value representing the seconds that the game waits before an event is triggered


- Background Music with LevelEvent
Background Music (BGM) can be controlled with the play_bgm() function. This function takes a single parameter:

stream - An AudioStreamOggVorbis that represents the audio file (an OGG) that is to be played by the game


- Background Scrolling with LevelEvent
The stage’s background scrolling can be adjusted using the background_scroll() function. This function takes two parameters:

pos_to - A float value that represents the vertical position that should be approached by the background scroll
time - A float value representing the time that should be taken to scroll to the location defined by pos_to


- Control Tags with LevelEvent
The LevelEvent system contains a “tag” system that can be used to keep track of triggers needed to cause an event to occur. It can be used to create systems for item generation and score bonuses, or for wave/stage completion status tracking. The function control_tag_wait() makes use of this. It takes one parameter:

value - An int value that is to be tracked by the tag


- Ending a stage
To end a stage, the void function level_end() can be called at the end of a stage’s code. This will add the LevelEndEvent to the end of the event list that is generated by the LevelEvent system, and it stops events from occuring (in other words, stopping the stage).


> Enemy and Enemy Pattern System
Aside from the LevelEvent system, there is also a customizable Enemy system that allows for the creation of any enemy type that is to be implemented in the game. Like the LevelEvent system, it is used as a base that can be extended by a child to create new enemy types as needed. The code is contained in the Enemy.gd file. Alongside this is the EnemyPattern system, found in the EnemyPattern.gd file, that controls the enemy’s attack patterns, which, again, can be extended to be used for the creation of new enemy attack patterns.


- Creating New Enemy Types
After creating a child that extends from Enemy.gd, multiple functions can be used to set up the enemy’s stats and general behavior. These are handled by functions that can be overriden by the programmer. General enemy variables are exported by default so that they can be changed as needed (such as HP). All enemies make use of a state machine to track its state, which are user-defined and can be customized as needed. There are a few general functions that are used for every enemy that is created using the Enemy class.

+ set_stats()
A void function to be overridden in children of the Enemy class. For general use cases, it should assign values for the hp, dodges, and score variables for the enemy. It should also assign a dictionary to the attribute_defaults variable, which should have key:value pairs for any additional enemy requirements (such as entry direction, speed, attack types, delays, etc.)


+ init_state(new_state, new_substate)
A void function to be overridden in children of the Enemy class. It takes two parameters:

new_state - A Status that represents the state of the enemy
new_substate - An int value representing the substate of the enemy’s state

Each enemy contains multiple states with substates that determine their behavior. The first line of the overridden function should be a call to its super function with the same parameters, super(new_state, new_substate). A match-case statement should then be used to handle each state. Enemies will have 4 main states: INIT, IDLE, ACTIVE, and DIE. Use a match-case statement for each Status.(status) as needed.


+ handle_state(current_state, current_substate)
A void function to be overridden in children of the Enemy class. This handles the state/substate of the enemy. It takes two parameters:

current_state - A Status representing the enemy’s current state
current_substate - An int representing the enemy’s current substate

Use a match-case statement to handle every state/substate change for the enemy as needed by the programmer. Match current_state to each Status.(status) as needed, and handle them as needed using the init_state()


+ init_state(new_state, new_substate)
A void function that initializes the new state, to be used for enemy state handling. It takes two parameters:

new_state - A Status representing the state that the enemy should transition to
new_substate - An int representing the substate that the enemy should transition to

It will change the enemy’s state and substate accordingly.


- Creating Enemy Patterns
New enemy patterns can be created by creating a child that extends from EnemyPattern. There are three main shot types that are used to create patterns: standard bullets, lasers, and sniper shots. There are also 4 main functions that handle these shots.

+ shoot_bullet_standard(angle_degrees, speed, position_offset, bullet_type, additional_attributes)
This function fires off a shot as a standard bullet. There are 5 parameters:

angle_degrees - A float representing the angle, in degrees, that the shot will be fired at
speed - A float representing the speed at which the shot will travel
position_offset - A float representing the positional offset of the shot fired
bullet_type - A PackedScene representing the bullet that will be fired as a “standard shot”
additional_attributes - A dictionary containing additional attributes, if any, needed for the shot. It is empty by default.


+ shoot_bullet_laser(_angle, bullet_type)
This function fires off a bullet in the form of a laser. It is currently being developed and is thus incompleted.


+ shoot_bullet_sniper(angle, bullet_type)
This function fires off a sniper shot. It takes two parameters:

angle - A float representing the angle at which the shot will be fired
bullet_type - A PackedScene representing the bullet type that will be fired as a “sniper shot.”


+ get_angle_to_player(start_position)
This function is used to get the angle to the player in degrees. It takes one parameter:

start_position - A Vector2 that represents the starting position from which the angle to the player is calculated.

Additional note: The get_angle_to_player() function is a useful tool in getting the angle to the player for any shots that are fired, allowing enemies to aim towards the player when needed.


> Final Words
This game’s complex systems, while somewhat confusing at first, provide a powerful tool to create stages and enemies for any bullet hell game that uses this game’s aiming system. The main system to be used is the LevelEvent system, which, by greatly abstracting the attributes of any generic stage, allows for in-depth customization of any stages and waves. Enemies and enemy patterns are also easily created with the Enemy and EnemyPattern classes. Overall, these systems provide all the tools for any kind of custom-made stages and enemies imaginable.
